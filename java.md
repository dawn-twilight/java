# 面向过程

> ###  面向过程：自顶向下的设计模式
>
> ```mermaid
> graph TD;
> 	main函数-->function1函数
> 	main函数-->function2函数
> 	main函数-->function3函数
> 	function1函数-->sub函数
> 	function3函数-->seb1函数
> 	function3函数-->seb2函数
> ```
>
> ### 特点：
>
> 分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现
>
> 以算法为核心
>
> 自顶向下设计，要求一开始对问题有很深的了解
>
> 将大问题转化位若干小问题来求解
>
> 表现形式：用函数来划分程序的基本单位
>
> 直接面对问题
>
> 
>
> ### 优点：
>
> 易于掌握和理解，符合人们的思维习惯
>
> 对于需求明确、规模不大、变动较小的问题非常适合
>
> ### 缺点：
>
> 数据与操作分离开，对数据和操作的修改变得很困难
>
> （注：操作不一定为数据专门设计，数据也可以通过其他方式改变）
>
> 数据的安全性得不到保障
>
> 程序架构的依赖关系不合理（注：程序的核心逻辑依赖于外延的细节）
>
> 对于需求不明确、规模大、变动大的问题很难解决

# 面向对象

> ### 特点
>
> 确定该问题由那些事物组成！先用类模拟出该事物
>
> 通过类间接的解决问题
>
> 自下而上设计，从问题的一部分着手，一点一点地构建出整个程序
>
> 表现形式：用类来作为划分程序的基本单位
>
> ### 优缺点
>
> 对于需求不明确、规模大、变动大的问题非常适合
>
> 对于需求明确、规模不大、变动较小的问题很累赘

## 类

> 把一类事物的静态属性和动态可以执行的操作组合在一起所得的这个概念就是类
>
> 类是抽象的，用来模拟一类事物，是一个概念
>
> 一旦被定义 ，类的概念就永远存在了

## 对象

> 类的一个个体
>
> 具体的，实实在在的事物（对于类来说）
>
> 生命周期是短暂的，会生成和消亡

## 内存分配

```java
class A{
		int i;
		int j;
		
}
public class Test01{
	
	public static void mian(String[] ages){
		A aa = new A();//(A *)malloc(sizeof(A));
			//new A();在堆中动态分配一块区域，被当作了A对象
			//aa本身的内存是在栈中分配的
			//堆中内存的地址赋给了aa
			//aa指向堆中的内存，aa代表了堆中的内存
		
		
		 
	}
	
}
```

![](D:\无标题.png)

### public static void main(String[] args){}主函数为什么带String[] args?

> 命令行传参

> 还有那个数组也必须叫args吗？
> 最佳答案
> 这个是运行程序前给它的参数。。
>
> 如果你在你程序要用这个参数的话就需要在运行前指定。。
>
> 比如java HelloWorld ceshi
> 那么在HelloWorld的main方法里面 args就是{"ceshi"}
> 多个的话用空格隔开..
> 比如java HelloWorld ceshi ceshi1 ceshi2
> 那么那么在HelloWorld的main方法里面 args就是{"ceshi", "ceshi1", "ceshi2"}
> 也就是说你假如你的程序是这样的
> public class HelloWorld{
>     public static void main(String[] args) {
>         System.out.println(args[0]);
>     }
> }
> 然后你编译
> 运行的时候这样运行
> java HelloWorld hello
> 那么这个程序就会输出hello
> 之所以是Stirng 是因为我们只能以字符串的形式输入
> 名字的话随便取。。只要符合java规定就行



